generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  name            String
  phone           String           @unique
  cpf             String?          // CPF para Asaas
  role            UserRole         @default(CUSTOMER)
  
  // ========== Campos de Autenticação (Login Email+Senha) ==========
  passwordHash    String?          // Hash bcrypt da senha (nullable para migração de usuários antigos)
  isActive        Boolean          @default(true)  // false = conta bloqueada
  failedAttempts  Int              @default(0)     // Tentativas de login falhas consecutivas
  lockedUntil     DateTime?        // Bloqueio temporário por rate limit
  lastLoginAt     DateTime?        // Último login bem-sucedido
  emailVerifiedAt DateTime?        // Data de verificação do email (null = não verificado)
  
  // ========== Reset de Senha ==========
  resetToken       String?         // Token único para reset (hash SHA-256)
  resetTokenExpiry DateTime?       // Expiração do token (1 hora)
  
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  bookings        Booking[]
  credits         Credit[]
  subletRequests  SubletRequest[]
  packages        UserPackage[]
  magicLinkTokens MagicLinkToken[]
  emailActivationTokens EmailActivationToken[]
  refundRequests  RefundRequest[]  @relation("UserRefundRequests")
  reviewedRefunds RefundRequest[]  @relation("AdminReviewedRefunds")
  couponUsages    CouponUsage[]
  refunds         Refund[]

  @@map("users")
}

model Room {
  id            String        @id @default(cuid())
  name          String
  slug          String        @unique
  description   String?
  imageUrl      String?
  capacity      Int           @default(2)
  amenities     String[]
  hourlyRate    Int           @default(0)
  pricePerHour  Int           @default(0)
  pricePackage4 Int           @default(0)
  pricePackage8 Int           @default(0)
  priceShift    Int           @default(0)
  tier          Int           @default(1) // 1=Consultório 1 (premium), 2=Consultório 2, 3=Consultório 3
  isActive      Boolean       @default(true)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  bookings      Booking[]
  products      Product[]
  credits       Credit[]
  packages      UserPackage[]

  @@map("rooms")
}

model Booking {
  id              String         @id @default(cuid())
  roomId          String
  userId          String
  productId       String?
  startTime       DateTime
  endTime         DateTime
  status          BookingStatus  @default(PENDING)
  paymentId       String?
  paymentStatus   PaymentStatus  @default(PENDING)
  amountPaid      Int            @default(0)
  paymentMethod   String?
  bookingType     BookingType    @default(HOURLY)
  packageUsageId  String?
  isSublet        Boolean        @default(false)
  originalUserId  String?
  subletRequestId String?
  notes           String?
  // Campos para rastreamento de créditos
  creditsUsed     Int            @default(0)  // Valor em centavos consumido de créditos
  creditIds       String[]       // IDs dos créditos consumidos
  isManual        Boolean        @default(false) // Reserva criada manualmente pelo admin
  // Campos para controle financeiro
  origin          BookingOrigin  @default(COMMERCIAL) // Origem: comercial ou cortesia
  financialStatus FinancialStatus @default(PENDING_PAYMENT) // Status financeiro
  courtesyReason  String?        // Motivo da cortesia (obrigatório se origin = ADMIN_COURTESY)
  // Campo para controle de envio de email
  emailSentAt     DateTime?      // Data/hora do envio do email de confirmação (evita duplicidade)
  // P0-4: Campos para cancelamento admin
  cancelSource    CancelSource?  // Quem cancelou: ADMIN, USER, SYSTEM
  refundType      RefundType?    // Tipo de devolução: CREDITS ou MONEY
  cancelledAt     DateTime?      // Data/hora do cancelamento
  cancelReason    String?        // Motivo do cancelamento
  // ========== AUDITORIA DE DESCONTO/CUPOM ==========
  grossAmount     Int?           // Valor bruto antes de desconto (centavos)
  discountAmount  Int?           // Valor do desconto aplicado (centavos)
  netAmount       Int?           // Valor líquido após desconto (centavos)
  couponCode      String?        // Código do cupom aplicado
  couponSnapshot  Json?          // Snapshot do cupom {discountType, value, description}
  // ========== EXPIRAÇÃO PARA CLEANUP AUTOMÁTICO ==========
  expiresAt       DateTime?      // Data/hora de expiração (para bookings PENDING sem pagamento)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  product         Product?       @relation(fields: [productId], references: [id])
  room            Room           @relation(fields: [roomId], references: [id])
  subletRequest   SubletRequest? @relation(fields: [subletRequestId], references: [id])
  user            User           @relation(fields: [userId], references: [id])
  refundRequest   RefundRequest?
  refund          Refund?

  @@index([roomId, startTime, endTime])
  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@map("bookings")
}

model UserPackage {
  id             String        @id @default(cuid())
  userId         String
  roomId         String?       // Sala específica do pacote (null = genérico)
  type           PackageType
  totalHours     Int
  usedHours      Int           @default(0)
  remainingHours Int
  purchaseDate   DateTime      @default(now())
  expiresAt      DateTime
  paymentId      String?
  paymentStatus  PaymentStatus @default(PENDING)
  amountPaid     Int           @default(0)
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  user           User          @relation(fields: [userId], references: [id])
  room           Room?         @relation(fields: [roomId], references: [id])

  @@index([userId, expiresAt])
  @@index([roomId])
  @@map("user_packages")
}

model Credit {
  id              String           @id @default(cuid())
  userId          String
  roomId          String?          // Sala específica do crédito (determina hierarquia)
  amount          Int              // Valor em centavos
  remainingAmount Int              @default(0) // Valor restante (para uso parcial)
  type            CreditType
  usageType       CreditUsageType? // Regra de uso: HOURLY, SHIFT, etc (null = legado)
  status          CreditStatus     @default(PENDING)
  subletRequestId String?
  sourceBookingId String?        // Booking que originou o crédito (cancelamento)
  referenceMonth  Int
  referenceYear   Int
  expiresAt       DateTime?
  usedAt          DateTime?
  // ========== AUDITORIA DE DESCONTO/CUPOM ==========
  grossAmount     Int?           // Valor bruto antes de desconto (centavos)
  discountAmount  Int?           // Valor do desconto aplicado (centavos)
  netAmount       Int?           // Valor líquido após desconto (centavos)
  couponCode      String?        // Código do cupom aplicado
  couponSnapshot  Json?          // Snapshot do cupom {discountType, value, description}
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  subletRequest   SubletRequest? @relation(fields: [subletRequestId], references: [id])
  user            User           @relation(fields: [userId], references: [id])
  room            Room?          @relation(fields: [roomId], references: [id])

  @@index([userId, status])
  @@index([roomId])
  @@map("credits")
}

model SubletRequest {
  id          String       @id @default(cuid())
  userId      String
  date        DateTime
  shiftType   ShiftType
  status      SubletStatus @default(PENDING)
  reviewedBy  String?
  reviewedAt  DateTime?
  reviewNotes String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  bookings    Booking[]
  credits     Credit[]
  user        User         @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@map("sublet_requests")
}

model Product {
  id            String      @id @default(cuid())
  name          String
  slug          String      @unique
  description   String?
  type          ProductType
  price         Int
  originalPrice Int?
  hoursIncluded Int?
  validityDays  Int?
  shiftType     ShiftType?
  roomId        String?
  isActive      Boolean     @default(true)
  isFeatured    Boolean     @default(false)
  sortOrder     Int         @default(0)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  bookings      Booking[]
  room          Room?       @relation(fields: [roomId], references: [id])

  @@index([roomId])
  @@map("products")
}

model Payment {
  id             String        @id @default(cuid())
  bookingId      String?
  purchaseId     String?       // ID do crédito (para compras de crédito)
  userId         String
  amount         Int
  status         PaymentStatus @default(PENDING)
  method         String?
  externalId     String?       // ID do pagamento no Asaas
  externalUrl    String?
  idempotencyKey String?       // Chave única para evitar cobranças duplicadas
  paidAt         DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // P-003: Indexes únicos para idempotência
  // Nota: unique parciais definidos na migration SQL
  @@index([externalId])
  @@index([bookingId])
  @@index([purchaseId])
  @@index([idempotencyKey])
  @@map("payments")
}

// ===========================================================
// Magic Link Token - Autenticação do Cliente
// ===========================================================
model MagicLinkToken {
  id          String    @id @default(cuid())
  userId      String
  tokenHash   String    @unique  // SHA-256 do token (nunca salvar token raw)
  expiresAt   DateTime           // 12 horas após criação
  usedAt      DateTime?          // Quando foi usado (null = não usado)
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("magic_link_tokens")
}

// Rate limit para magic links (3 por hora por email)
model MagicLinkRateLimit {
  id        String   @id @default(cuid())
  email     String
  attempts  Int      @default(1)
  windowStart DateTime @default(now())
  
  @@unique([email])
  @@map("magic_link_rate_limits")
}

// ===========================================================
// Email Activation Token - Ativação de Conta (checkout anônimo)
// ===========================================================
model EmailActivationToken {
  id          String    @id @default(cuid())
  userId      String
  tokenHash   String    @unique  // SHA-256 do token + PEPPER (nunca salvar token raw)
  expiresAt   DateTime           // 12 horas após criação
  usedAt      DateTime?          // Quando foi usado (null = não usado)
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("email_activation_tokens")
}

// ===========================================================
// Webhook Event - Idempotência para webhooks Asaas
// ===========================================================
model WebhookEvent {
  id          String   @id @default(cuid())
  eventId     String   @unique  // ID do evento do Asaas
  eventType   String             // PAYMENT_RECEIVED, etc
  paymentId   String?            // ID do pagamento no Asaas
  bookingId   String?            // ID do booking relacionado
  status      String   @default("PROCESSED")  // PROCESSED, FAILED, SKIPPED
  payload     Json?              // Payload completo para debug
  processedAt DateTime @default(now())
  
  @@index([eventId])
  @@index([paymentId])
  @@index([processedAt])
  @@map("webhook_events")
}

model AuditLog {
  id         String      @id @default(uuid())
  action     AuditAction
  source     AuditSource
  actorId    String?
  actorEmail String?
  actorIp    String?
  userAgent  String?
  targetType String?
  targetId   String?
  metadata   Json?
  createdAt  DateTime    @default(now())

  @@index([action])
  @@index([source])
  @@index([targetType, targetId])
  @@index([createdAt])
  @@index([actorEmail])
  @@map("audit_logs")
}

enum UserRole {
  CUSTOMER
  ADMIN
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum PaymentStatus {
  PENDING
  APPROVED
  REJECTED
  REFUNDED
  IN_PROCESS
}

enum BookingType {
  HOURLY
  PACKAGE
  SHIFT
  SUBLET
}

enum PackageType {
  HOURS_4
  HOURS_8
}

enum CreditType {
  SUBLET
  PROMO
  CANCELLATION  // Crédito gerado por cancelamento
  SATURDAY      // Crédito específico para sábado
  MANUAL        // Crédito criado manualmente pelo admin
}

enum CreditStatus {
  PENDING
  CONFIRMED
  USED
  EXPIRED
  REFUNDED
}

// Tipo de uso do crédito (regra de agendamento)
// Nullable para compatibilidade com créditos legados
enum CreditUsageType {
  HOURLY            // Hora avulsa seg-sex (1h fixa)
  SHIFT             // Turno fixo seg-sex (4h em bloco: 08-12, 12-16, 16-20)
  SATURDAY_HOURLY   // Hora sábado (1h fixa)
  SATURDAY_SHIFT    // Turno sábado (4h em bloco: 08-12)
}

enum ShiftType {
  MORNING
  AFTERNOON
}

enum SubletStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum ProductType {
  HOURLY_RATE
  PACKAGE_10H
  PACKAGE_20H
  PACKAGE_40H
  SHIFT_FIXED
  DAY_PASS
  SATURDAY_HOUR
  SATURDAY_5H
  SATURDAY_SHIFT
  PROMO
}

enum AuditAction {
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  BOOKING_EXPIRED
  BOOKING_MANUAL_CREATED
  BOOKING_COURTESY_CREATED
  BOOKING_CANCELLED_AUTO
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  PAYMENT_BACKFILL
  CREDIT_CREATED
  CREDIT_USED
  CREDIT_EXPIRED
  CREDIT_REFUNDED
  ADMIN_LOGIN
  ADMIN_LOGOUT
  ADMIN_BOOKING_VIEW
  ADMIN_BOOKING_UPDATE
  ADMIN_BACKFILL_EXECUTED
  ALERT_PAYMENT_NOT_CONFIRMED
  USER_LOGIN
  USER_LOGIN_FAILED
  USER_LOGOUT
  USER_REGISTER
  USER_MAGIC_LINK_REQUESTED
  USER_MAGIC_LINK_RATE_LIMITED
  PASSWORD_RESET_REQUESTED
  PASSWORD_RESET_COMPLETED
  // Refund workflow
  REFUND_REQUESTED
  REFUND_REVIEWING
  REFUND_APPROVED
  REFUND_REJECTED
  REFUND_PAID
}

// Origem da reserva: comercial ou cortesia
enum BookingOrigin {
  COMMERCIAL
  ADMIN_COURTESY
}

// Status financeiro da reserva
enum FinancialStatus {
  PENDING_PAYMENT
  PAID
  COURTESY
  REFUNDED        // P-007: Estornado via gateway ou chargeback
  PARTIAL_REFUND  // Refund parcial - aguarda revisão manual
}

enum AuditSource {
  USER
  ADMIN
  SYSTEM
}

// ===========================================================
// RefundRequest - Pedido de Estorno Manual
// ===========================================================
// Ticket para processamento manual de estornos
// Não automatiza PIX - apenas registra e controla workflow

model RefundRequest {
  id              String       @id @default(cuid())
  bookingId       String       @unique
  userId          String
  amount          Int          // Valor em centavos a devolver
  pixKeyType      PixKeyType
  pixKey          String       // Chave PIX do cliente
  status          RefundStatus @default(REQUESTED)
  reason          String?      // Motivo do pedido (opcional)
  reviewedBy      String?      // userId do admin que revisou
  reviewedAt      DateTime?    // Data da revisão
  reviewNotes     String?      // Notas internas do admin
  rejectionReason String?      // Motivo da rejeição (obrigatório se REJECTED)
  proofUrl        String?      // Link do comprovante de pagamento
  paidAt          DateTime?    // Data do pagamento efetivo
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  booking         Booking      @relation(fields: [bookingId], references: [id])
  user            User         @relation("UserRefundRequests", fields: [userId], references: [id])
  reviewer        User?        @relation("AdminReviewedRefunds", fields: [reviewedBy], references: [id])

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("refund_requests")
}

enum RefundStatus {
  REQUESTED   // Pedido feito pelo cliente
  REVIEWING   // Admin em análise
  APPROVED    // Aprovado, aguardando pagamento
  PAID        // Pago (estorno concluído)
  REJECTED    // Rejeitado pelo admin
}

// P0-4: Quem cancelou a reserva
enum CancelSource {
  ADMIN       // Admin cancelou via painel
  USER        // Usuário cancelou (histórico - agora bloqueado)
  SYSTEM      // Sistema cancelou (auto-cancel por não pagamento)
}

// P0-4: Tipo de devolução ao cancelar
enum RefundType {
  CREDITS     // Devolver como crédito para usar no sistema
  MONEY       // Devolver como dinheiro (cria RefundRequest)
  NONE        // Sem devolução (< 48h ou sem valor)
}

enum PixKeyType {
  CPF
  CNPJ
  EMAIL
  PHONE
  RANDOM
}

model RateLimit {
  id          String   @id @default(cuid())
  key         String   @unique // formato: "action:identifier"
  requests    Int      @default(0)
  windowStart DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([windowStart])
  @@map("rate_limits")
}

// ===========================================================
// Settings - Configurações do sistema (Marketing, Integrações)
// ===========================================================
// Armazena configurações dinâmicas que não exigem rebuild
// Formato key-value com tipagem e metadata

model Setting {
  id          String   @id @default(cuid())
  key         String   @unique // ex: "META_PIXEL_ID", "GA_MEASUREMENT_ID"
  value       String   // Valor da configuração
  type        String   @default("string") // string, boolean, number, json
  category    String   @default("general") // general, marketing, integrations
  description String?  // Descrição para UI
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@map("settings")
}

// ===========================================================
// AuditEvent - Eventos de auditoria para observabilidade
// ===========================================================
// Registro de eventos críticos do sistema (best-effort)
// Usado para debugging, compliance e análise

model AuditEvent {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  requestId   String?  // Correlation ID do request
  type        String   // BOOKING_CREATED, PURCHASE_CREATED, PAYMENT_CONFIRMED, etc
  userId      String?  // ID do usuário (quando disponível)
  entityType  String   // Booking, Credit, Payment, etc
  entityId    String   // ID da entidade
  payloadJson Json?    // Dados adicionais (metadata)

  @@index([type])
  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_events")
}

// ===========================================================
// Coupon - Cupons de Desconto (Gerenciamento Dinâmico)
// ===========================================================
// Tabela para gerenciar cupons de desconto dinamicamente
// Suporta cupons de percentual, valor fixo e override de preço

model Coupon {
  id              String        @id @default(cuid())
  code            String        @unique // Código do cupom (ex: ARTHEMI10)
  discountType    String        // 'fixed' | 'percent' | 'priceOverride'
  value           Int           // Valor em centavos para 'fixed'/'priceOverride', em % para 'percent'
  description     String        // Descrição do cupom
  singleUsePerUser Boolean      @default(false) // true = cupom só pode ser usado 1x por usuário
  isDevCoupon     Boolean       @default(false) // true = cupom de desenvolvimento
  isActive        Boolean       @default(true)  // false = cupom desativado
  validFrom       DateTime?     // Data de início da validade (null = sem limite)
  validUntil      DateTime?     // Data de fim da validade (null = sem limite)
  minAmountCents  Int?          // Valor mínimo em centavos para aplicar o cupom (null = sem mínimo)
  maxUses         Int?          // Número máximo de usos totais (null = ilimitado)
  currentUses     Int           @default(0)    // Número atual de usos
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  usages          CouponUsage[]

  @@index([code])
  @@index([isActive])
  @@index([validUntil])
  @@map("coupons")
}

// ===========================================================
// CouponUsage - Rastreamento de Uso de Cupons (Anti-Fraude)
// ===========================================================
// Registra cada uso de cupom para impedir reutilização indevida
// Especialmente importante para PRIMEIRACOMPRA (única por usuário)

model CouponUsage {
  id         String            @id @default(cuid())
  userId     String
  couponCode String            // Código do cupom (ex: PRIMEIRACOMPRA)
  couponId   String?           // ID do cupom (quando vem da tabela Coupon)
  context    CouponUsageContext
  bookingId  String?
  creditId   String?
  status     CouponUsageStatus @default(USED)
  createdAt  DateTime          @default(now())
  restoredAt DateTime?         // Data de restauração (quando aplicável)
  
  user       User              @relation(fields: [userId], references: [id])
  coupon     Coupon?           @relation(fields: [couponId], references: [id])

  @@unique([userId, couponCode, context]) // Impede cupom duplicado no mesmo contexto
  @@index([couponCode])
  @@index([couponId])
  @@index([userId])
  @@map("coupon_usages")
}

enum CouponUsageContext {
  BOOKING
  CREDIT_PURCHASE
}

enum CouponUsageStatus {
  USED
  RESTORED // Restaurado (para cupons reutilizáveis - não inclui PRIMEIRACOMPRA)
}

// ===========================================================
// Refund - Registro de Reembolso para Idempotência
// ===========================================================
// Garante que um booking só pode ter UM reembolso
// Registra valores corretos (NET + créditos usados, NUNCA gross)

model Refund {
  id                 String            @id @default(cuid())
  bookingId          String            @unique // UNIQUE = um refund por booking
  userId             String
  
  // Valores para auditoria
  creditsReturned    Int               // Valor em centavos devolvido como crédito
  moneyReturned      Int               // Valor em centavos devolvido como dinheiro
  totalRefunded      Int               // creditsReturned + moneyReturned
  
  // Campos para refund parcial
  expectedAmount     Int?              // Valor total esperado (NET + créditos)
  refundedAmount     Int?              // Valor efetivamente estornado pelo gateway
  isPartial          Boolean           @default(false) // true = refund parcial
  
  // Gateway/Método de devolução
  gateway            RefundGateway     @default(MANUAL)
  externalRefundId   String?           // ID do refund no Asaas (quando via API)
  
  // Status do reembolso
  status             RefundRecordStatus @default(PENDING)
  
  // Metadados
  reason             String?           // Motivo do reembolso
  processedBy        String?           // ID do admin que processou
  processedAt        DateTime?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  
  booking            Booking           @relation(fields: [bookingId], references: [id])
  user               User              @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
  @@map("refunds")
}

enum RefundGateway {
  MANUAL  // Créditos gerados manualmente no sistema
  ASAAS   // Devolução via API do Asaas
}

enum RefundRecordStatus {
  PENDING   // Aguardando processamento
  COMPLETED // Reembolso concluído com sucesso
  FAILED    // Falha no processamento
}

// ===========================================================
// MetaEventContext - Contexto para Meta CAPI (deduplicação)
// ===========================================================
// Persiste event_id e dados do cliente para correlacionar
// eventos Pixel (client-side) com CAPI (server-side)
// Garante deduplicação obrigatória pelo Meta

model MetaEventContext {
  id          String    @id @default(cuid())
  eventId     String    // UUID gerado no client ou server (dedup key)
  eventName   String    // Purchase, Schedule, Lead, etc
  entityType  String    // Booking, Credit
  entityId    String    // ID da entidade relacionada
  fbp         String?   // _fbp cookie do cliente
  fbc         String?   // _fbc cookie do cliente (click ID)
  clientIp    String?   // IP do cliente (para CAPI match)
  userAgent   String?   // User-Agent do cliente
  sourceUrl   String?   // URL de origem do evento
  capiSentAt  DateTime? // Quando o CAPI foi enviado
  capiStatus  String?   // SENT, FAILED, SKIPPED
  createdAt   DateTime  @default(now())

  @@unique([eventName, entityType, entityId]) // Um contexto por evento+entidade
  @@index([entityType, entityId])
  @@index([eventId])
  @@map("meta_event_contexts")
}